using SyncDbContext.Attributes;
using SyncDbContext.Models;
using System;
using System.Collections.Generic;
using System.Data.Entity;
using System.Data.Entity.Core.Mapping;
using System.Data.Entity.Core.Metadata.Edm;
using System.Data.Entity.Infrastructure;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SyncDbContext.Helpers
{
    public static class EntityHelper<TEntity>
    {
        public static EntitySetMapping GetEntitySetMapping(Type type, DbContext context)
        {
            var objContext = ((IObjectContextAdapter)context).ObjectContext;
            var metadata = objContext.MetadataWorkspace;

            // Get the part of the model that contains info about the actual CLR types
            var objectItemCollection = ((ObjectItemCollection)metadata.GetItemCollection(DataSpace.OSpace));

            var entityItems = metadata.GetItems<EntityType>(DataSpace.OSpace);

            // Get the entity type from the model that maps to the CLR type
            var entityType = entityItems
                    .Single(e => objectItemCollection.GetClrType(e) == type);

            // Get the entity set that uses this entity type
            var entitySet = metadata
                .GetItems<EntityContainer>(DataSpace.CSpace)
                .Single()
                .EntitySets
                .Single(s => s.ElementType.Name == entityType.Name);

            // Find the mapping between conceptual and storage model for this entity set
            return metadata.GetItems<EntityContainerMapping>(DataSpace.CSSpace)
                    .Single()
                    .EntitySetMappings
                    .Single(s => s.EntitySet == entitySet);
        }

        // Alternative, allows you to compare `== Identity`, `== Computed`, `!= None`, etc:
        public static StoreGeneratedPattern GetSSpaceScalarColumnStoreGeneratedPattern(EdmProperty property)
        {
            return property.MetadataProperties.TryGetValue("http://schemas.microsoft.com/ado/2009/02/edm/annotation:StoreGeneratedPattern", false, out MetadataProperty item)
                ? (StoreGeneratedPattern)Enum.Parse(typeof(StoreGeneratedPattern), item.Value.ToString())
                : System.Data.Entity.Core.Metadata.Edm.StoreGeneratedPattern.None;
        }

        public static UpsertModel<TEntity> GetUpsertModel(DbContext context, string schema = "dbo")
        {
            var mapping = GetEntitySetMapping(typeof(TEntity), context);
            // Get the name of the primary key for the table as we wish to exclude this from the column mapping (we are assuming Identity insert is OFF)
            //https://romiller.com/2015/08/05/ef6-1-get-mapping-between-properties-and-columns/

            //If you're doing split entities to separate sync logic, recommend using a different schema and this filter
            var fragment = mapping
                .EntityTypeMappings.Single()
                .Fragments.Where(f => f.StoreEntitySet.Schema == schema).First();

            var _propNames = fragment
                .PropertyMappings
                .OfType<ScalarPropertyMapping>()
                .Where(p => GetSSpaceScalarColumnStoreGeneratedPattern(p.Property) != StoreGeneratedPattern.Computed) //don't want to update computed columns
                .ToDictionary(m => m.Property.Name, m => '[' + m.Column.Name + ']');

            var keyNames = mapping.EntitySet.ElementType.KeyMembers
                .ToLookup(k => (k.IsStoreGeneratedIdentity), k => k.Name);

            var _entityPrimaryKeyNames = keyNames.SelectMany(k => k).ToList();

            if (_propNames.HasSameKeys(_entityPrimaryKeyNames))
            {
                throw new Exception("Can't upsert entity that has only primary keys");
            }

            var _storeGeneratedPrimaryKeyNames = keyNames[true].ToList();

            // Find the storage entity set (table) that the entity is mapped
            var table = fragment
                .StoreEntitySet;

            // Return the table name from the storage entity set
            var _tableName = (string)table.MetadataProperties["Table"].Value ?? table.Name;
            var schemaName = (string)table.MetadataProperties["Schema"].Value ?? table.Schema;
            _tableName = $"[{schemaName}].[{_tableName}]";

            return new UpsertModel<TEntity>
            {
                PropertyNames = _propNames,
                AutoGeneratedFields = _storeGeneratedPrimaryKeyNames,
                KeyFields = _entityPrimaryKeyNames,
                FullTableName = _tableName
            };
        }
    }
}
